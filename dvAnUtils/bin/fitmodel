#!/usr/bin/env python
"""
.. script:: fitmodel -- Fitting an observable to a default selected model
==============================================================================
   :platform: Unix
      :synopsis: Quick fitting of a pdf model for an observable. First 
                 approximation which can be used to setup the workspace to 
                 start to work in.
    .. scriptauthor:: Jordi Duarte-Campderros <jorge.duarte.campderros@cern.ch>
"""

def preFit(data,obs,modelname,modeltype,ops_instance):
    """ Perform a pre-fit using the simple negative binomial (just 2 parameters
    to fit per binomial, (P, K). In this way, the value of the probability is
    used it as the initial value of the probability of the conditional one:
     
    P <= p <= 1 (using the relation P=p*eff/(1-p*(1-eff)) )
    
    Parameters
    ----------
    data: ROOT.RooData
        The data
    obs: str
        The name of the observable
    modelname: str
        The name of the model (as in the `pdfmodels` module)
    modeltype: str
        The type of the model inside the ops_instance
    ops_instance:
        The ObservableSamplingProb instance object used to change the value of the
        initial parameters
    """
    from dvAnUtils.samplingprob import ObservableSamplingProb,parameter_names_from_model
    print 
    print "\033[1;34mfitmodel.preFit [INFO]\033[m Performing a pre-fit for the "\
            "'{0}' function".format(modelname)
    print
    
    # pre-processing: the available observable, the model, the parameters for the model
    premodel = modelname.replace('_conditional','')
    model    = ops_instance.getmodel(modeltype)
    parameters = filter(lambda x: x != obs.GetName() and x.find('eff') == -1, 
            parameter_names_from_model(model))

    # Processing the non-conditional model
    sd = ObservableSamplingProb(obs)
    sd.setupmodel('preFit',premodel)
    sd.fitTo(data,'preFit')
    
    print 
    print "\033[1;34mfitmodel.preFit [INFO]\033[m Changing initial guessing of "\
            "the parameters according to the previous fit"
    print
    
    # set the new points
    for par_name in parameters:
        par_new_value = sd.get_variable_from_model('preFit',par_name).getVal()
        # change the initial point
        ops_instance.get_variable_from_model(modeltype,par_name).setVal(par_new_value)
        # extra: using the constrain between efficiency and probability of success
        if par_name.find('p') != -1:
            ops_instance.get_variable_from_model(modeltype,par_name).setMin(par_new_value)


def main(inputfile,obs,pdfdict,do_prefit=False):
    """Steering function. Performs a initial tentative fit of the data
    using a predefined pdf models. The output is stored in a ROOT file
    as a ROOT.Workspace.
    

    Parameters
    ----------
    inputfile: str
        The ROOT file name
    obs: str
        The name of the observable
    """
    from dvAnUtils.samplingprob import readfile,ObservableSamplingProb
    # Obtaining the info from the root file
    f,obsdict,modeldict,databkgdict,datasigdict = readfile(inputfile)
    if not obsdict.has_key(obs):
        raise RuntimeError("Observable '%s' not defined" % obs)
    sd = ObservableSamplingProb(obsdict[obs])
    # Does contain signal?
    has_signal_content = False
    if len(datasigdict) != 0:
        has_signal_content = True

    # Setting up the sampling probability model(s)
    sd.setupmodel('bkg',pdfdict['bkg'])
    
    # Getting the data to be used to fit
    databkg = databkgdict['dvbkg_'+obs]
    
    # In case conditional probability, perform a pre-fit to obtain a
    # good initial value for p and k
    if do_prefit and pdfdict['bkg'].find('conditional') != -1:
        preFit(databkg,obsdict[obs],pdfdict['bkg'],'bkg',sd)
    
    # Perform the fit
    sd.fitTo(databkg,'bkg')
    
    samplename = inputfile.split('_')[1]
    # And plot!
    sd.plot(samplename+'_bkg_'+obs+'.pdf',databkg,'bkg')
    
    # Same for the signal content if any
    if has_signal_content:
        sd.setupmodel('sig',pdfdict['sig'])
        datasig = datasigdict['dvsig_'+obs]
        if do_prefit and pdfdict['sig'].find('conditional') != -1:
            preFit(datasig,obsdict[obs],pdfdict['sig'],'sig',sd)
        sd.fitTo(datasig,'sig')
        sd.plot(samplename+'_sig_'+obs+'.pdf',datasig,'sig')

    extratag = '_bkg_'
    if has_signal_content:
        extratag = '_bkgsig_'

    # Create the ROOT file with the WS to continue working
    containertoupdate = [databkg]
    if has_signal_content:
        containertoupdate.append(datasig)
    nfile = inputfile.split('_')[1]+extratag+obs+'_ws.root'
    sd.update('w',nfile,containertoupdate)
    
if __name__ == '__main__':
    from optparse import OptionParser
    import os
    
    usage = "fitmodels.py ROOTFILE [options]"
    usage +="\n\nQuick fitting of a pdf [hardcoded] model  for an observable.\n"
    usage +="First approximation which can be used to setup the workspace\nto"
    usage +=" start to work with."

    parser = OptionParser(usage=usage)
    parser.set_defaults(obs='ntracks',models=None,do_prefit=False)
    parser.add_option( "-o","--observable",action='store',dest='obs',\
            help="Name of the observable [ntracks]")
    parser.add_option( "-p","--pre-fit",action='store_true',dest='do_prefit',\
            help="Whether or not perform a pre-fit of the binomials using"\
            " the the minimum amount of nuisance parameters, i.e. 'p' and 'k'" )
    parser.add_option( "-m","--models",action='store',dest='models',\
            metavar="COMPONENT1:MODEL1[,COMPONENT2:MODEL2,...]",
            help="Name of the model(s) to be used (must exits at dVAnUtils.pdfmodels)"\
                    " [bkg:negative_binomial_pdf_conditional,"\
                    "sig:negative_binomial_sum_pdf_conditional]")

    (opt,args) = parser.parse_args()
    if len(args) != 1:
        message = "\033[31mfitmodel ERROR\033[m Mandatory argument ROOTFILE)"
        raise RuntimeError(message)
    
    # Check the root file
    if not os.path.isfile(args[0]):
        raise IOError("ROOT file '%s' not found" % args[0])
    # Parse the model option
    comp_model_dict = { 'bkg': 'negative_binomial_pdf_conditional',
            'sig':'negative_binomial_sum_pdf_conditional' }
    if opt.models:
        for compmodel in opt.models.split(","):
            try: 
                component,model = compmodel.split(":")
            except ValueError:
                message = "\033[31mfitmodel ERROR\033[m Invalid format for the option"\
                        " '-m','--models'. Please see help"
                raise RuntimeError(message)
            comp_model_dict[component]=model

    main(args[0],opt.obs,comp_model_dict,opt.do_prefit)
    
