#!/usr/bin/env python
"""
.. script:: fitmodel -- Fitting an observable to a default selected model
==============================================================================
   :platform: Unix
      :synopsis: Quick fitting of a pdf model for an observable. First 
                 approximation which can be used to setup the workspace to 
                 start to work in.
    .. scriptauthor:: Jordi Duarte-Campderros <jorge.duarte.campderros@cern.ch>
"""

# INITIAL VALUES FOR PARAMETERS TYPE:
INIT_VALUES = { 'ptype' : 0.8, 'qtype': 0.2, 'efftype': 0.7, 'ktype' : 3 }

def set_initial_value(parameter_name,parameter,val_min=None,val_max=None):
    """Set the initial point to the parameter before starts the minimization

    Parameters
    ----------
    parameter_name: str
        The name of the parameter
    parameter: ROOT.RooAbsReal
        The actual parameter        
    val_min,val_max: float|int, optional
        The minimum and maximum allowed values for the paramater
    """
    # Guess from the name the type of the parameter
    if parameter_name.find('eff') == 0:
        point_type = 'efftype'
    elif parameter_name.find('p') == 0:
        point_type = 'ptype'
    elif parameter_name.find('k') == 0:
        point_type = 'ktype'
    else:
        # not recognized, don't do anything
        return

    parameter.setVal(INIT_VALUES[point_type])
    if val_min:
        parameter.setMin(val_min)
    if val_max:
        parameter.setMax(val_max)


def preFit(data,obs,modelname,modeltype,ops_instance):
    """ Perform a pre-fit using the simple negative binomial (just 2 parameters
    to fit per binomial, (P, K). In this way, the value of the probability is
    used it as the initial value of the probability of the conditional one:
     
    P <= p <= 1 (using the relation P=p*eff/(1-p*(1-eff)) )
    
    Parameters
    ----------
    data: ROOT.RooDataSet|ROOT.RooDatHist
        The data
    obs: str
        The name of the observable
    modelname: str
        The name of the model (as in the `pdfmodels` module)
    modeltype: str
        The type of the model inside the ops_instance
    ops_instance:
        The ObservableSamplingProb instance object used to change the value of the
        initial parameters
    """
    from dvAnUtils.samplingprob import ObservableSamplingProb,parameter_names_from_model
    print 
    print "\033[1;34mfitmodel.preFit [INFO]\033[m Performing a pre-fit for the "\
            "'{0}' function".format(modelname)
    print
    
    # pre-processing: the available observable, the model, the parameters for the model
    premodel = modelname.replace('_conditional','')
    model    = ops_instance.getmodel(modeltype)
    parameters = filter(lambda x: x != obs.GetName() and x.find('eff') == -1, 
            parameter_names_from_model(model))

    # Processing the non-conditional model
    sd = ObservableSamplingProb(obs)
    sd.setupmodel('preFit',premodel)
    sd.fitTo(data,'preFit')
    
    print 
    print "\033[1;34mfitmodel.preFit [INFO]\033[m Changing initial guessing of "\
            "the parameters according to the previous fit"
    print
    
    # set the new points
    for par_name in parameters:
        par_new_value = sd.get_variable_from_model('preFit',par_name).getVal()
        # change the initial point
        ops_instance.get_variable_from_model(modeltype,par_name).setVal(par_new_value)
        # extra: using the constrain between efficiency and probability of success
        if par_name.find('p') != -1:
            ops_instance.get_variable_from_model(modeltype,par_name).setMin(par_new_value)

def main(inputfile,obs,pdfdict,do_prefit=False,suffix='pdf'):
    """Steering function. Performs a initial tentative fit of the data
    using a predefined pdf models. The output is stored in a ROOT file
    as a ROOT.Workspace.
    

    Parameters
    ----------
    inputfile: str
        The ROOT file name
    obs: str
        The name of the observable
    """
    from dvAnUtils.samplingprob import readfile,ObservableSamplingProb,parameter_names_from_model
    # Obtaining the info from the root file
    f,obsdict,modeldict,databkgdict,datasigdict = readfile(inputfile)
    if not obsdict.has_key(obs):
        raise RuntimeError("Observable '%s' not defined" % obs)
    sd = ObservableSamplingProb(obsdict[obs])
    # Does contain signal?
    has_signal_content = False
    if len(datasigdict) != 0:
        has_signal_content = True

    # Setting up the sampling probability model(s)
    sd.setupmodel('bkg',pdfdict['bkg'])
    
    # Getting the data to be used to fit
    databkg = databkgdict['dvbkg_'+obs]
    
    if do_prefit:
        # Perform a pre-fit to obtain a good initial value for p and k
        preFit(databkg,obsdict[obs],pdfdict['bkg'],'bkg',sd)
    else:
        # Otherwise, set the initial values
        for _parname in parameter_names_from_model(sd.getmodel('bkg')):
            set_initial_value(_parname,sd.get_variable_from_model('bkg',_parname))
    
    # Perform the fit
    sd.fitTo(databkg,'bkg')
    
    samplename = inputfile.split('_')[1]
    # And plot!
    sd.plot(samplename+'_bkg_'+obs+'.pdf',databkg,'bkg',plot_suffix=suffix)
    
    # Same for the signal content if any
    if has_signal_content:
        sd.setupmodel('sig',pdfdict['sig'])
        datasig = datasigdict['dvsig_'+obs]
        if do_prefit:
        # Perform a pre-fit to obtain a good initial value for p and k
            preFit(datasig,obsdict[obs],pdfdict['sig'],'sig',sd)
        else:
            # Otherwise, set the initial values
            for _parname in parameter_names_from_model(sd.getmodel('sig')):
                set_initial_value(_parname,sd.get_variable_from_model('sig',_parname))
        sd.fitTo(datasig,'sig')
        sd.plot(samplename+'_sig_'+obs+'.pdf',datasig,'sig',plot_suffix=suffix)

    extratag = '_bkg_'
    if has_signal_content:
        extratag = '_bkgsig_'

    # Create the ROOT file with the WS to continue working
    containertoupdate = [databkg]
    if has_signal_content:
        containertoupdate.append(datasig)
    nfile = inputfile.split('_')[1]+extratag+obs+'_ws.root'
    sd.update('w',nfile,containertoupdate)
    
if __name__ == '__main__':
    from argparse import ArgumentParser
    import os
    
    usage  ="Quick fitting of a pdf [hardcoded] model  for an observable."
    usage +="First approximation which can be used to setup the workspace to"
    usage +=" start to work with."

    parser = ArgumentParser(prog='fitmodel',description=usage)#,allow_abbrev=False)
    parser.add_argument('rootfilename',type=str,action='store',\
            metavar='ROOTFILE',
            help="ROOT file containing the RooDataSet"\
            " or RooDataHist data (previously processed by roibasisconverter)")
    parser.set_defaults(obs='ntracks',models=None,do_prefit=False,suffix='pdf')
    parser.add_argument( "-o","--observable",action='store',dest='obs',\
            help="Name of the observable [ntracks]")
    parser.add_argument( "-p","--pre-fit",action='store_true',dest='do_prefit',\
            help="Whether or not perform a pre-fit of the binomials using"\
            " the the minimum amount of nuisance parameters, i.e. 'p' and 'k'" )
    parser.add_argument( "-m","--models",action='store',dest='models',\
            metavar="COMPONENT1:MODEL1[,COMPONENT2:MODEL2,...]",
            help="Name of the model(s) to be used (must exits at dVAnUtils.pdfmodels)"\
                    " [bkg:negative_binomial_pdf_conditional,"\
                    "sig:negative_binomial_sum_pdf_conditional]")
    parser.add_argument( "-s","--suffix-plot",action='store',dest='suffix',\
            help="Suffix format for the plots [pdf]")

    args = parser.parse_args()
    
    # Check the root file
    if not os.path.isfile(args.rootfilename):
        raise IOError("ROOT file '%s' not found" % args.rootfilename)
    # Parse the model option
    comp_model_dict = { 'bkg': 'negative_binomial_pdf_conditional',
            'sig':'negative_binomial_sum_pdf_conditional' }
    if args.models:
        for compmodel in args.models.split(","):
            try: 
                component,model = compmodel.split(":")
            except ValueError:
                message = "\033[31mfitmodel ERROR\033[m Invalid format for the option"\
                        " '-m','--models'. Please see help"
                raise RuntimeError(message)
            comp_model_dict[component]=model

    main(args.rootfilename,args.obs,comp_model_dict,args.do_prefit,args.suffix)
    
