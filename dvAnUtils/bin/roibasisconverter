#!/usr/bin/env python
""":script:`roibasisconverter` -- Convert per-event ntuple to a roi-base ntuple
===============================================================================

.. script:: roibasisconverter
   :platform: Unix
      :synopsis: Convert an root file generated by the package rpvmctruthinfo
                 (an Athena AthAlgorithm, see
                 https://github.com/duartej/rpvmctruthinfo), which stores 
                 information into ntuples per-event base (as usual). After 
                 being processed by this script, the root file final will 
                 contain a ntuple (TTree) in a per-RoI base, i.e., the 'rows'
                 of the file corresponds to a RoI (instead of an event). The
                 processing of the file includes the generation and persistency
                 of the Roofit classes (RooDataSet and RooRealVar) needed to
                 perform the statistic/probabilistic analysis.
                 
                 See also
                 --------
                 samplingprob: sampling probabilistic analysis classes

    .. scriptauthor:: Jordi Duarte-Campderros <jorge.duarte.campderros@cern.ch>
"""

def getrpvinfo(inputfile):
    """Get the 'RPVMCInfoTree' from the root inputfile

    Parameters
    ----------
    inputfile: str
               The name of the ROOT input file containing
               the tree RPVMCInfoTree
    
    Returns
    -------
    dvAnUtils.trigeffclass.rpvmcinfo 
       An instance of the rpvmcinfo is created

    See Also
    --------
    dvAnUtils.trigeffclass.rpvmcinfo: Encapsulating the RPVMCInfoTree content
    """
    from dvAnUtils.trigeffclass import rpvmcinfo

    return rpvmcinfo([inputfile])


def createdata(obsdetails,outfile,tree):
    """Build a ROOT file in the Roofit format using
    the observable choosen by the user

    Parameters
    ----------
    obsdetails: (str,str,float,float)
               4-tuple which contains several details about
               the observable:
                * name of the observable
                * title to be used with the observable
                * min value accepted
                * max value accepted
    outfile: str
             Name of the output ROOT file where the Roofit
             classes are going to be stored
    tree: ROOT.TTree
          The tree object where the information is going to
          be imported
    """
    from ROOT import TFile
    from ROOT import RooDataSet,RooDataHist,RooRealVar, RooCategory, RooArgSet
    from ROOT.RooFit import Import

    # Open root file 
    # NOTE: the root file is open here due to the potential memory
    #       problems. Not having a ROOT open could fill totally the
    #       stack, raising a alloc exception
    outrootfile = outfile.replace('.root','')+'.root'
    tfile       = TFile(outrootfile,"UPDATE")
    # First check if the tree contains some signal or is only
    # background
    istheresignal= (tree.GetEntries("isSignal==1") != 0)
    # =======================================================
    # CREATE MODEL and DATASETS
    # =========================
    # Observable
    # ----------
    obsname = obsdetails[0]
    obstitle= obsdetails[1]
    obsmin  = obsdetails[2]
    obsmax  = obsdetails[3]
    obsbins = obsdetails[4]
    # -- Check if no signal and the observable is signal-only
    if not istheresignal and obsname in ['phi_0','phi_1','eta_0','eta_1']:
        # do nothing 
        tfile.Close()
        return
    # -- Check if the observable is in the tree
    if obsname not in map(lambda x: x.GetName(),tree.GetListOfBranches()):
        raise RuntimeError("Observable '%s' did not find it in the tree" % obsname)
    
    observable = RooRealVar(obsname,obstitle,obsmin,obsmax)
    isSignal= RooCategory("isSignal","is RoI-signal?")
    isSignal.defineType("RoI_signal")
    isSignal.defineType("RoI_bkg")

    # ==========================
    # DATASETS
    # --------
    dvrois_ds  = RooDataSet("dvrois_"+obsname,"dvrois "+obsname, 
            RooArgSet(observable,isSignal),Import(tree))
    # Construct bkg and signal datasets 
    dvbkg_ds  = dvrois_ds.reduce("isSignal == 0")
    dvbkg_ds.SetName('dvbkg_'+obsname)
    dvsign_ds = dvrois_ds.reduce("isSignal == 1")
    dvsign_ds.SetName("dvsig_"+obsname)

    if obsbins:
        # Binning the RooDatasets
        observable.setBins(obsbins)
        auxsuffix='_tobedumped'
        dvrois_ds.SetName(dvrois_ds.GetName()+auxsuffix)
        dvrois = RooDataHist(dvrois_ds.GetName().replace(auxsuffix,''),
                dvrois_ds.GetTitle(),
                RooArgSet(observable,isSignal),dvrois_ds)
        dvsign_ds.SetName(dvsign_ds.GetName()+auxsuffix)
        dvsign = RooDataHist(dvsign_ds.GetName().replace(auxsuffix,''),
                dvsign_ds.GetTitle(),
                RooArgSet(observable,isSignal),dvsign_ds)
        dvbkg_ds.SetName(dvbkg_ds.GetName()+auxsuffix)
        dvbkg = RooDataHist(dvbkg_ds.GetName().replace(auxsuffix,'')
                ,dvbkg_ds.GetTitle(),
                RooArgSet(observable,isSignal),dvbkg_ds)
    else:
        dvrois = dvrois_ds
        dvsign = dvsign_ds
        dvbkg  = dvbkg_ds

    # ===========================
    # Persistency
    # -----------
    outrootfile = outfile.replace('.root','')+'.root'
    tfile       = TFile(outrootfile,"UPDATE")
    observable.Write()
    dvrois.Write()
    dvbkg.Write()
    if istheresignal:
        dvsign.Write()
    tfile.Close()


def createws(oname):
    """TO BE DEPRECATED: Memory problems

    Deprecation Warning
    -------------------
    """
    import shutil
    import os
    import ROOT 

    tfilename = oname.replace('.root','')+'.root'
    w = ROOT.RooWorkspace("w","Workspace")
    # Workaround to use the method 'import' (the same name 
    # as the python built-in )
    wsImport = getattr(w,'import')
    # Open the file, preparing to convert the content in
    # a workspace
    shutil.copy(tfilename,'_prov.root')
    f = ROOT.TFile('_prov.root')
    ffinal = ROOT.TFile(tfilename,'RECREATE')
    ffinal.cd()
    # Put everything in memory
    for b in f.GetListOfKeys():
        if (b.GetClassName() == 'RooDataSet') or \
                (b.GetClassName() == 'RooRealVar'):
            wsImport(f.Get(b.GetName()))
        elif b.GetClassName() == 'TTree':
            t = f.Get((b.GetName()))
            t.Write()
    w.Write()
    ffinal.Close()
    f.Close()
    os.remove('_prov.root')


def main(args,outfiles):
    """Steer main function.

    The input root(s) file(s) is(are) must contain a RPVMCInfoTree 
    ROOT.TTree (see also https://github.com/duartej/rpvmctruthinfo)
    which are going to be processed to convert the per-event file
    structure to an per-RoI one.


    Parameters
    ----------
    args: list(str)
          Input from the command line. First element must 
          contain a comma separated root file names

    outfiles: list(str)
          Output file names. The format is exactly the same 
          as the `args`. 
    """
    import os
    
    # (varname,title,minval,maxval,Bins|None)
    # if the Bins!= None, it is implies the the data will be 
    # built with the RooDataHist, using Bins
    obsdetails = [ ("ntracks","N_{t} per RoI",1,100,100),
            ("ntracksd0uppercut","RoI #eta",1,30,30),  # FIXME!!! --> From 0 on
            ("ntracksd0lowercut","RoI #eta",1,80,80),  # FIXME!!! --> From 0 on
            ("sumpttracksd0uppercut","RoI #eta",0,100e6,None),
            ("sumpttracksd0lowercut","RoI #eta",0,100e6,None),
            ("phi_0","LSP_{0} #phi",-3.15,3.15,None),
            ("eta_0","LSP_{0} #eta",-6.5,6.5,None),
            ("phi_1","LSP_{1} #phi",-3.15,3.15,None),
            ("eta_1","LSP_{1} #eta",-6.5,6.5,None),
            ("jetroi_phi","RoI #phi",-3.15,3.15,None),
            ("jetroi_eta","RoI #eta",-6.5,6.5,None)
            ]


    rootfiles = args[0].split(',')
    # Check there are in there
    notfound = filter(lambda x: not os.path.isfile(x), rootfiles)
    for i in notfound:
        raise IOError("No such root file: '%s'" % i)
    # Get the rpvminfo instances
    # opt.outfiles already pre-processed
    inoutfiles = zip(rootfiles,outfiles)
    rpvinsts = dict(map(lambda (inf,outf): (outf.replace('.root',''),getrpvinfo(inf)),
                    inoutfiles))
    # And build the new tree-format for RooFit analysis
    # The observables to be stored:('ntracks','ntracks','jetroi_phi','jetroi_eta')
    obs = ('ntracks','ntracksd0uppercut','sumpttracksd0uppercut',
            'ntracksd0lowercut','sumpttracksd0lowercut','jetroi_phi','jetroi_eta')
    obssignalonly = ('phi_0','phi_1','eta_0','eta_1')
    # -- Loop for all the files (rpvmc instances)
    #    NOT WORKING PROPERLY YET!! FIXME
    for outfile,rpv in rpvinsts.iteritems():
        processedtree, rootfile = rpv.roofitTree(obs,obssignalonly,
                outfile,treename='roofitRPVMCInfoTree')
        # REady for the Statistical sampling analysis:
        # Create the data for further analisis
        for od in obsdetails:
            createdata(od,outfile,processedtree)
        if rootfile:
            rootfile.Close()
        
if __name__ == '__main__':
    from optparse import OptionParser
    
    usage = "samplingdist ROOTFILE1[,FILE2,...] [options]"
    parser = OptionParser(usage=usage)
    parser.add_option( "-o",action='store',dest='outfiles',\
            metavar="FILE1[,FILE2,...]",help="Name of the output root files"\
            " containing the RooFit Workspace. Note that the number of files"\
            " should be the same as introduced in the arguments [As default"\
            " uses the arguments plus '_sd_processed' before .root suffix]")

    (opt,args) = parser.parse_args()
    if len(args) != 1:
        message = "\033[31msamplingdist ERROR\033[m Missing input"\
                " root file(s) to process"
        raise RuntimeError(message)
    
    if opt.outfiles:
        if len(args[0].split(',')) != len(opt.outfiles.split(',')):
            raise RuntimeError("The same number of input files than output"\
                    " files must be introduced")
        outfiles = opt.outfiles.split(',')
    else:
        import os
        outfiles = map(lambda x: os.path.basename(x.replace('.root','_sd_processed.root')),
                args[0].split(','))

    main(args,outfiles)





    
