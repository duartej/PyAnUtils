#!/usr/bin/env python
""":script:`clustermanager` -- Send, check and retrieve jobs to a cluster
=================================================================================

.. script:: clustermanager <send|retrieve> [OPTIONS]    
      :platform: Unix
      :synopsis: Send, check and retrieve jobs to a cluster. 
.. moduleauthor:: Jordi Duarte-Campderros <jorge.duarte.campderros@cern.ch>
"""

DEBUG=True
JOBEVT=500
from PyAnUtils.jobssender import athenajob,cerncluster,bookeepingjobs,accessingjobsinfo

if __name__ == '__main__':
    from optparse import OptionParser,OptionGroup
    import os

    usage  = "usage: %prog <send|retrieve|kill> [options]"
    parser = OptionParser(usage=usage)

    parser.add_option("-w","--workingpath",action="store",dest="workingpath",\
            help="Prepare/send the jobs in this path")
    parser.add_option('-b','--bashname',action='store',dest='bashname',
            help='name of the bash script without extension (the script'+\
                    ' used to send the job, which defines also the name of the job')
    parser.add_option('-s','--dry-run',action='store_true',dest='dryrun',
            help='Simulate the action but does not send the commands to the cluster')

    sendopt= OptionGroup(parser,"Send mode options",
            "Options valid only when it is called with 'send' arg")
    sendopt.add_option("-j","--jobOption",action="store",dest="joboption",\
            help="Name of the python jobOption file")
    sendopt.add_option("-i","--inputfiles",action="store",dest="filenames",\
            help="Input root files (can be regular expresion)")
    sendopt.add_option("-n","--njobs",action="store",dest="njobs",\
            help="Force the number of jobs to be sent")
    sendopt.add_option("-e","--evtsmax",action="store",dest="evtsmax",\
            help="Number of events to be processed")
    parser.add_option_group(sendopt)

    #retropt= OptionGroup(parser,"Retrieve mode options",
    #        "Options valid only when it is called with 'retrieve' arg")
    #parser.add_option_group(retropt)
    
    killopt= OptionGroup(parser,"Kill job mode options",
            "Options valid only when it is called with 'kill' arg")
    killopt.add_option("-l","--list",action="store",dest="joblisttokill",\
            help="List of jobs to be killed, if this option is not activated"\
                " all running jobs will be killed")
    parser.add_option_group(killopt)

    parser.set_defaults(bashname='clusterRPVMCInfoDVMuons',dryrun=False,
            joboption='testBjetSliceAthenaTrigRDO.py',
            filenames = '/afs/cern.ch/user/d/duarte/work/public/datasets/'\
                    'mc14_13TeV.177568.Pythia_AUET2BCTEQ6L1_RPV_vtx2_LSP100'\
                    '_mujets_filtDL_Rmax300.recon.RDO.e3355_s1982_s2008_r5787'\
                    '_tid04569111_00/*.pool.root.*',
                    njobs=300,
                    workingpath='./')

    (opt,args) = parser.parse_args()
    print "================================================================"
    print "\033[1;33mWARNING:\033[1;m Some functionalities are not developed yet. The program"
    print "is just able to send 'athena' jobs in the 'cern' cluster"
    print "================================================================"

    if len(args) != 1:
        raise RuntimeError('%prog must be called either with "send|retrieve"'\
                ' arguments')
    if args[0] == 'send':
        cwd = os.getcwd()
        os.chdir(os.path.abspath(opt.workingpath))

        jobs = athenajob(opt.bashname,opt.joboption,opt.filenames,
                njobs=opt.njobs)
        jobs.preparejobs()
        cern = cerncluster(jobs.getlistofjobs(),simulate=opt.dryrun)
        cern.submit()
        bookeepingjobs(jobs,cern)
        #print "Send the jobs using this:"
        #print "for i in `echo */*.sh`; do j=`echo $i|cut -d/ -f1`;"\
        #        "echo $j;cd $j; bsub -q 8nh %s; cd ..;  done;" % \
        #        (jobs.scriptname+'.sh')a
        os.chdir(cwd)

    elif args[0] == 'retrieve':
        import glob
    
        print "Searching jobs..."
        try:
            shfile = glob.glob(os.path.join(opt.workingpath,'.presentjobs'))[0]
        except IndexError:
            raise RuntimeError('Not found jobs in the folder "%s"(, '\
                ' i.e. not found ".presentjobs" file) ' % opt.workingpath)
        jspec,clspec = accessingjobsinfo(shfile)
        for jdsc in jspec.getlistofjobs():
            clspec.getnextstate(jdsc,jspec.checkfinishedjob)
            print "INFO::JOB [%s] state: %s, status: %s" % (str(jdsc.index),jdsc.state,jdsc.status)
            # Check the state and status and act as consequence
            #clspec.gonextstate(jdsc)
        bookeepingjobs(jspec,clspec)
        
    elif args[0] == 'kill':
        import glob

        print "Searching jobs to be killed...",
        try:
            shfile = glob.glob(os.path.join(opt.workingpath,'.presentjobs'))[0]
        except IndexError:
            raise RuntimeError('Not found jobs in the folder "%s"(, '\
                ' i.e. not found ".presentjobs" file) ' % opt.workingpath)
        jspec,clspec = accessingjobsinfo(shfile)
        if not opt.joblisttokill:
            indexjobstobekilled = jspec.getlistofjobs()
        else:
            indexjobstobekilled  = opt.joblisttokill

        jobstobekill = filter(lambda x: x.index in indexjobstobekilled,jspec.getlistofjobs())
        print "%s" % str(jobstobekill)
        for jdsc in jobstobekill:
            clspec.kill(jdsc)
        bookeepingjobs(jspec,clspec)
    else:
        raise RuntimeError('Not valid argument "%s".'\
                ' Valid args: send|aretrieve' % args[0])



