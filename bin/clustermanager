#!/usr/bin/env python
""":script:`clustermanager` -- Send, check and retrieve jobs to a cluster
=================================================================================

.. script:: clustermanager <send|retrieve> [OPTIONS]    
      :platform: Unix
      :synopsis: Send, check and retrieve jobs to a cluster. 
.. moduleauthor:: Jordi Duarte-Campderros <jorge.duarte.campderros@cern.ch>
"""

DEBUG=True
JOBEVT=500
from PyAnUtils.jobssender import athenajob,cerncluster,bookeepingjobs,accessingjobsinfo

if __name__ == '__main__':
    from optparse import OptionParser,OptionGroup
    import os

    usage  = "usage: %prog <send|retrieve> [options]"
    parser = OptionParser(usage=usage)

    parser.add_option('-b','--bashname',action='store',dest='bashname',
            help='name of the bash script without extension (the script'+\
                    ' used to send the job, which defines also the name of the job')
    parser.add_option('-s','--dry-run',action='store_true',dest='dryrun',
            help='Simulate the action but does not send the commands to the cluster')

    sendopt= OptionGroup(parser,"Send mode options",
            "Options valid only when it is called with 'send' arg")
    sendopt.add_option("-j","--jobOption",action="store",dest="joboption",\
            help="Name of the python jobOption file")
    sendopt.add_option("-i","--inputfiles",action="store",dest="filenames",\
            help="Input root files (can be regular expresion)")
    sendopt.add_option("-n","--njobs",action="store",dest="njobs",\
            help="Force the number of jobs to be sent")
    sendopt.add_option("-e","--evtsmax",action="store",dest="evtsmax",\
            help="Number of events to be processed")
    parser.add_option_group(sendopt)

    retropt= OptionGroup(parser,"Retrieve mode options",
            "Options valid only when it is called with 'retrieve' arg")
    retropt.add_option("-w","--workingpath",action="store",dest="workingpath",\
            help="Path to the folder where the jobs were sent")
    parser.add_option_group(retropt)

    parser.set_defaults(bashname='clusterRPVMCInfoDVMuons',dryrun=False,
            joboption='testBjetSliceAthenaTrigRDO.py',
            filenames = '/afs/cern.ch/user/d/duarte/work/public/datasets/'\
                    'mc14_13TeV.177568.Pythia_AUET2BCTEQ6L1_RPV_vtx2_LSP100'\
                    '_mujets_filtDL_Rmax300.recon.RDO.e3355_s1982_s2008_r5787'\
                    '_tid04569111_00/*.pool.root.*',
                    njobs=300,
                    workingpath='./')

    (opt,args) = parser.parse_args()
    print "================================================================"
    print "\033[1;33mWARNING:\033[1;m Some functionalities are not developed yet. The program"
    print "is just able to send 'athena' jobs in the 'cern' cluster"
    print "================================================================"

    if len(args) != 1:
        raise RuntimeError('%prog must be called either with "send|retrieve"'\
                ' arguments')
    if args[0] == 'send':
        jobs = athenajob(opt.bashname,opt.joboption,opt.filenames,
                njobs=opt.njobs)
        jobs.preparejobs()
        cern = cerncluster(jobs.getlistofjobs(),simulate=opt.dryrun)
        cern.submit()
        bookeepingjobs(jobs,cern)

        #print "Send the jobs using this:"
        #print "for i in `echo */*.sh`; do j=`echo $i|cut -d/ -f1`;"\
        #        "echo $j;cd $j; bsub -q 8nh %s; cd ..;  done;" % \
        #        (jobs.scriptname+'.sh')

    elif args[0] == 'retrieve':
        import os
        import glob
    
        print "Searching jobs..."
        try:
            shfile = glob.glob(os.path.join(opt.workingpath,'.presentjobs'))[0]
        except IndexError:
            raise RuntimeError('Not found jobs in the folder "%s"(, '\
                ' i.e. not found ".presentjobs" file) ' % opt.workingpath)
        jspec,clspec = accessingjobsinfo(shfile)
        for jdsc in jspec.getlistofjobs():
            if DEBUG:
                print "--Job [%s]::State: %s, Status: %s" % (str(jdsc.index),jdsc.state,jdsc.status)
            clspec.getnextstate(jdsc,jspec.checkfinishedjob)
            # Check the state and status and act as consequence
            #clspec.gonextstate(jdsc)
        bookeepingjobs(jspec,clspec)
        
    #elif args[0] == 'kill':
    #    print "Searching jobs..."
    #    try:
    #        shfile = glob.glob(opt.workingpath+'.presentjobs')[0]
    #    except IndexError:
    #        raise RuntimeError('Not found jobs in the folder "%s"(, '\
    #            ' i.e. not found ".presentjobs" file) ' % opt.workingpath)
    #    jspec,clspec = accesingjobsinfo(shfile)
    #    for jdsc in jspec.getlistofjobs():
    #        if DEBUG:
    #            print "--Job [%s]::Killing it..." % (str(jdsc.index))
    #        clspec.kill(jdsc)
    else:
        raise RuntimeError('Not valid argument "%s".'\
                ' Valid args: send|aretrieve' % args[0])



