#!/usr/bin/env python
""":script:`lazycmt` -- Compiles cmt directories in the Athena framework
===================================================

.. script:: lazycmt <build|clean> [OPTIONS]    
      :platform: Unix
      :synopsis: Search the cmt directories presents in a release Athena directory
   and perform the compilation, cleaning or other programmed action. 

	  .. moduleauthor:: Jordi Duarte-Campderros <jorge.duarte.campderros@cern.ch>
"""
DEBUG=False

def iscompiled(p):
	""".. function:: iscompiled(p) --> bool

	Checks the output of the Popen.communicate call, contains
	an error.

	:p: The ouput of the subprocess.Popen.communicate call, (stdout,stderr)
	:type p: (str, str)

	:return: If the error word was found (False) or not (True)
	:rtype: bool
	"""
	if p[0].lower().find('error') != -1 or \
			p[1].lower().find('error') != -1:
				return False
	return True


def findcmtdirs(pardir,targetdir = 'cmt'):
	""".. function:: findcmtdir(pardir) --> cmtdir
	
	Perform a recursively search down for the cmt directory
	Return a list of directories

	::FIXME:: Function to be put in a generic module
	"""
	import os
	matches = []
	for root, dirnames, filenames in os.walk(pardir):
		if len(filter(lambda x: x == targetdir, dirnames)) == 1:
			matches.append( os.path.join(root,targetdir))
	return matches

def sendshellcommand(command,d):
	""".. function:: sendshellcommand(command,d) 

	Send a shell command using as current working directory d.
	Checks for any output error, which prints
	
	:command: command to be executed
	:type command: string
	"""
	from subprocess import Popen,PIPE

	p = Popen(command,cwd=d,stdout=PIPE,stderr=PIPE,shell=True).communicate()
	if DEBUG:
		print p[1],p[0]
	if not iscompiled(p):
		print "\033[31mlazycmt CONFIGURATION ERROR\033[m: [%s]" % (d.split('/')[-2])

def config(wd):
	""".. function:: configure(wd)

	Configure all packages found inside the wd, by searching the cmt directory

	:wd: Parent directory where to find recursively 'cmt' directories
	:type wd: str
	"""
	cmtdirs = findcmtdirs(wd)
	command = 'cmt.exe config'
	for d in cmtdirs:
		sendshellcommand(command,d)

def build(wd,ncpu):
	""".. function:: build(wd)
	
	Build all packages found inside the wd, by searching the cmt directory
	
	:wd: Parent directory where to find recursively 'cmt' directories
	:type wd: str
	:ncpu: number of available cpu for make
	:type ncpu: int
	"""
	cmtdirs = findcmtdirs(wd)
	command = 'cmt.exe make -j'+str(ncpu)
	for d in cmtdirs:
		print "Building directory '%s'" % d
		sendshellcommand(command,d)
	
def clean(wd,ncpu,forcedel=False):
	"""..function:: clean(wd,ncpu)

	Clean all packages found inside the wd, by searching the cmt directory

	:wd: Parent directory where to find recursively 'cmt' directories
	:type wd: str
	:ncpu: number of available cpu for make
	:type ncpu: int
	"""
	import os 
	import shutil
	import glob
	from subprocess import Popen,PIPE	

	cwd = os.getcwd()
	cmtdirs = findcmtdirs(wd)
	removedirs = [ 'genConf', os.getenv('CMTCONFIG') ]
	for d in cmtdirs:
		print "Cleaning directory '%s'" % d
		os.chdir(d)
		command2 = 'cmt.exe clean -j'+str(ncpu)
		command =  'gmake clean'
		p = Popen(command,cwd=d,stdout=PIPE,stderr=PIPE,shell=True).communicate()
		p2 = Popen(command2,cwd=d,stdout=PIPE,stderr=PIPE,shell=True).communicate()
		# Check if there is directories to remove
		for k in removedirs:
			rmdir = os.path.join(os.path.join(d,'..'),k)
			shutil.rmtree(rmdir, ignore_errors=True)
	os.chdir(cwd)
	# A proper clean will remove the contents of InstallArea
	# directory

	# -- Extracting the InstallArea directory (assuming all packages are
	#    under the same main directory--repo dir
	iadir=cmtdirs[0]
	found = False
	while (not found) and (len() != 0):
		for root,dirs,files in os.walk(iadir):
			if 'InstallArea' not in dirs:
				iadir='/'.join(iadir.split('/')[:-1])
			else:
				found=True
			break
	if iadir.find('InstallArea') == -1:
		message = "\033[31mlazycmt.clean ERROR\033[m Problems finding the InstallArea"
		message+= " directory"
		raise RuntimeError(message)
	# -- Assuming that the package name is in the path, just before cmt
	pkgnames = map(lambda x: x.split('/')[-2], cmtdirs)
	# Removing the Install area related pkgs
	for pkg in pkgnames:
		relateddirs=glob.glob(iadir+"/*/*"+pkg+"*")
		relateddirs+=glob.glob(iadir+"/*/lib/lib"+pkg+"*")
		for k in relateddirs:
			shutil.rmtree(k,ignore_errors=True)


if __name__ == '__main__':
	from optparse import OptionParser
	import os

	usage  = "usage: lazycmt.py <build|clean> [options]"
	parser = OptionParser(usage=usage)
	parser.add_option( "-p",action='store',dest='packages', metavar="PKG[,...]",\
			help="just build|clean this package(s)")
	parser.add_option( "-d",action='store_true',dest='debug', default=False,\
			help="print full output from 'cmt'")

	(opt,args) = parser.parse_args()
	if len(args) != 1:
		message = "\033[31mlazycmt ERROR\033[m Missing mandatory argument: build|clean"
		raise RuntimeError(message)
	else:
		if args[0] != 'build' and args[0] != 'clean':
			message = "\033[31mlazycmt ERROR\033[m Missing mandatory argument: build|clean."
			message+= " (Introduced argument: '%s')" % args[0]
			raise RuntimeError(message)

	if opt.packages:
		wd = opt.packages
	else:
		wd = os.getcwd()
	# number of cpu's
	import multiprocessing
	ncpu=multiprocessing.cpu_count()
	# do the job
	if args[0] == 'build':
		if opt.debug:
			DEBUG=True
		config(wd)
		build(wd,ncpu)
	elif args[0] == 'clean':
		clean(wd,ncpu)

