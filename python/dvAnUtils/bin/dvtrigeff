#!/usr/bin/env python
""":script:`gettrigeff` -- Extract and build DV trigger efficiencies from ntuple
===================================================

.. script:: gettrigeff [options]    
      :platform: unix
      :synopsis: extract, build and plot trigger efficiencies from a ROOT ttree
      The script has two working modes:
        1. actually extract and build the trigger efficiencies found in a ROOT tree
        and get MC information related. This working mode is highly dependent on
        the ntuple datamembers. How to extract the information is encapsulated in
        the .....
        2. plotting the efficiencies previously obtained using the mode 1. This
        mode is independent from any ntuple, so it can be used to genericaly 
        plot efficiencies as far as the root input file keep the expected format:
        TBranches of TEfficiency objects
.. moduleauthor:: jordi duarte-campderros <jorge.duarte.campderros@cern.ch>
"""
DEBUG=False

### Fent  
## mc_prod_vx_x-mc_prod_vx_x[0])**2.+(mc_prod_vx_y-mc_prod_vx_y[0])**2)','mc_status == 1 && mc_pdgId[mc_parent_index] == 1000022'
## no estic segur, pero tens la posicio del vertex on s'ha desintegrat el neutrali...
## nota que el vertex primari, on ocurreix la primera interaccio (en el cas de RPV) es a mc_prod_vx_x,y,z[0]

# Pseudo ROOT colors
kBlack=1
kRed=632
kGreen=416
kAzure=860
kCyan=432
kOrange=800

COLORS = [ kBlack, kOrange-2, kRed+2, kAzure+3,kCyan-2,kGreen-2,\
		kOrange+7, kRed-3, kAzure-3, kCyan+4, kGreen+4 ]
TEXTSIZE = 0.03


class effsv(object):
    """..class:: effsv
    This class encapsulate a trigger efficiency
    """
    def __init__(self,trnameslist=None):
        """...class:: effsv([trnameslist=None]) 
        Trigger efficiency obtained from different ntuples (see 
        ????? method). The efficiency object is stored with respect
        some variables, which allows to plot the efficiency versus
        these variables
        """
        import ROOT

        self.__var__= [ 'Dtdv', 'Dzdv', 'Drdv',  # SV with respect Primary vertex
                'tdv', 'zdv', 'rdv' ]             # SV with absolute position
        self.__histos__ = [ 'eta','phi','betagamma',         # Kinematics of the DVs
                'nTrk4mm',                       # Number of status-1 genparticles 
                                                 # decayed from the DVs (in a 4mm radius)
                ]
        self.__xtitle__ = { 'Dtdv': 'r_{DV} [mm]' ,\
                'Dzdv': 'r_{z} [mm]',\
                'Drdv': 'radial distance [mm]',\
                'tdv': 'transverse r_{DV} [mm]', 'zdv': 'longitudinal r_{DV} [mm]', 'rdv': 'r_{DV} [mm]',\
                'eta': '#eta_{DV}', 'phi': '#phi_{DV}', 'betagamma': '#beta#gamma_{DV}',\
                'nTrk4mm': 'N_{trk}^{4mm}',\
                }
        # Efficiencies       
        self.__effs__ = {}
        # If there is no list of triggers, there will be set later...
        if trnameslist: 
            self.__trgnames__ = trnameslist
            # Each variable is associated with a dictionary of the trigger chains availables 
            # { 'var1': { 'trpath1': TEfficiency, 'trpath2': TEfficiency, ....}, ... } 
            for i in self.__var__:
                self.__effs__[i] = dict(map(lambda x: (x,ROOT.TEfficiency(geteffname(x,i),'',100,0,300)),
                    trnameslist))
                ## -- And the OR key
                self.__effs__[i]["OR"] = ROOT.TEfficiency('eff'+i+'_OR','',100,0,300)
        else:
            self.__trgnames__ = []

    def gettrgnames(self):
        """.. method:: gettrgnames() -> trgnames
        The list of the trgnames
        """
        return self.__trgnames__

    def fill(self,trname,varname,decission,varvalue):
        """
        """
        self.__effs__[varname][trname].Fill(decission,varvalue)

    def __plot__(self,trname,varname):
        """
        """
        import ROOT
        from PyAnUtils.plotstyles import atlasStyle

        lstyle = atlasStyle()
        ROOT.gROOT.SetBatch()
        
        c = ROOT.TCanvas()
        h = c.DrawFrame(0,0,300.0,1.0)
        h.SetXTitle(self.__xtitle__[varname])
        h.SetYTitle('#varepsilon_{MC}')
        h.SetTitle(trname)
        h.Draw()
        self.__effs__[varname][trname].Draw("PSAME")
        c.SaveAs('eff_'+trname+'_'+varname+'.png')

    def __plotsamecanvas__(self,triglist,varname):
        """
        """
        import ROOT
        from PyAnUtils.plotstyles import atlasStyle
        from PyAnUtils.pyanfunctions import drawlegend
        
        lstyle = atlasStyle()
        ROOT.gROOT.SetBatch()
        
        c = ROOT.TCanvas()
        h = c.DrawFrame(0,0,300.0,1.0)
        h.SetXTitle(self.__xtitle__[varname])
        h.SetYTitle('#varepsilon_{MC}')
        #h.SetTitle(trname)
        h.Draw()
        legend = ROOT.TLegend() 
        legend.SetBorderSize(0) 
        legend.SetTextSize(TEXTSIZE) 
        legend.SetFillColor(10) 
        legend.SetTextFont(112)
        _j = 0
        for trname in triglist:
            self.__effs__[varname][trname].SetLineColor(COLORS[_j])
            self.__effs__[varname][trname].SetMarkerStyle(20)
            self.__effs__[varname][trname].SetMarkerSize(0.5)
            self.__effs__[varname][trname].SetMarkerColor(COLORS[_j])
            self.__effs__[varname][trname].SetFillColor(COLORS[_j])
            legend.AddEntry(self.__effs__[varname][trname],trname,'PL')
            self.__effs__[varname][trname].Draw("PSAME")
            _j += 1
        drawlegend(legend,'CENTER',0.90)
        c.SaveAs('eff_GroupedTriggers'+'_'+varname+'.png')


    def plot(self,trname=None,varname=None):
    	"""
    	"""
    	if trname and varname:
            if type(trname) is list:
                self.__plotsamecanvas__(trname,varname)
            else:
                self.__plot__(trname,varname)
        else:
            for trgname in self.__trgnames__:
                for varname in self.__var__:
                    self.__plot__(trgname,varname)


    def seteffobj(self,trname,varname,effobject):
    	"""
    	"""
    	if trname not in self.__trgnames__:
            self.__trgnames__.append(trname)
        try:
            self.__effs__[varname][trname] = effobject
        except KeyError:
            self.__effs__[varname] = { trname: effobject }

    def saverootfile(self,name):
    	"""
    	"""
    	import ROOT
    	f = ROOT.TFile.Open(name,'RECREATE')
    	for effd in self.__effs__.values():
    		for effroot in effd.values():
    			effroot.Write()
    	f.Close()

    def showresults(self):
        """..method:: showresults
        print the results of the trigger chains PER OBJECT (DV)
        """
        effcalc = {}
        varname = self.__effs__.keys()[0]
        for trn,eff in self.__effs__[varname].iteritems():
            passed = float(eff.GetPassedHistogram().GetEntries())
            total  = float(eff.GetTotalHistogram().GetEntries())
            try:
                effcalc[trn] = float(passed)/float(total)
            except ZeroDivisionError:
                effcalc[trn] = 0.0
        maxlen = max(map(lambda x: len(x),self.__effs__[varname].keys()))
        pformat = "%"+str(maxlen)+"s:: %.3f%s"
        for trn,val in sorted(effcalc.iteritems(),key=lambda (x,y): y):
            print pformat % (trn,val*100,'%')
    

def geteffname(trname,varname):
    """
    """
    name = 'eff'+varname+'_'+trname
    return name

def gettriggernamefrom(fullname):
    """
    """
    return fullname.split('eff'+getvarnamefrom(fullname)+'_')[-1]

def getvarnamefrom(fullname):
    """
    """
    return fullname.split('eff')[-1].split('_')[0]


def gettreechain(rfiles):
    """
    """
    import ROOT
    import os 
    t = ROOT.TChain('RPVMCInfoTree')
    print "TChain 'RPVMCInfoTree' created"
    print "Adding %i root files to the tree" % len(rfiles)
    for i in sorted(rfiles):
    	t.AddFile(i)
    
    return t

def gettriggersnames(t):
    """
	"""
    triggersinntuple = []
    for tbranch in filter(lambda x: x.GetName().find('HLT')==0 and \
            x.GetName().lower().find('jetroi') == -1,t.GetListOfBranches()):
        triggersinntuple.append( tbranch.GetName() )
    return triggersinntuple
#	import shelve
#	f = shelve.open('BjetsTriggersMenu12.db')
#
#	bjetstriggers = f['bjetmenu12']
#	leaveslist = [x.GetName() for x in t.GetListOfLeaves()]
#	# Add also, a check
#	trgRun1 = []
#	trgRun1.append('EF_g120_loose')
#	trgRun1.append('EF_2g40_loose')
#	trgRun1.append('EF_mu50_MSonly_barrel_tight')
#	triggersinntuple = list(set(bjetstriggers.keys()+trgRun1).intersection(leaveslist))
#	print "Obtaining trigger names from reference '%s'" % f['source']
#	print ":::Found %i trigger paths from reference" % len(bjetstriggers.keys())
#	print ":::Found %i trigger paths in the trees" % len(triggersinntuple)

    return triggersinntuple

def setuptree(t,triggerbr):
    """
    """

    from array import array

    #t.SetBranchStatus("*",0)
    trarrays = {}
    for i in triggerbr:
        trarrays[i] = array('b',[False])
        #t.SetBranchStatus(i,1)
        # It is not needed anymore, because
        # the new mechanism in root which you
        # can recover as attribute the branc
        t.SetBranchAddress(i,trarrays[i])

    # Monte Carlo truth, displaced vertex like
    #t.SetBranchStatus('mc_end_vx_x',1)
    #t.SetBranchStatus('mc_end_vx_y',1)
    #t.SetBranchStatus('mc_end_vx_z',1)
    #t.SetBranchStatus('mc_prod_vx_x',1)
    #t.SetBranchStatus('mc_prod_vx_y',1)
    #t.SetBranchStatus('mc_prod_vx_z',1)
    ##t.SetBranchStatus('mc_parent_index',1)
    #t.SetBranchStatus('mc_pdgId',1)
    #t.SetBranchStatus('mc_status',1)
    return trarrays

def getdr(t,i):
    """
    """
    from math import sqrt
    dx= t.mc_prod_vx_x[i]-t.mc_end_vx_x[i]
    dy= t.mc_prod_vx_y[i]-t.mc_end_vx_y[i]
    dz= t.mc_prod_vx_z[i]-t.mc_end_vx_z[i]
    return sqrt(dx**2.+dy**2+dz**2.)

def getindexllp(t):
    """
    """
    nmc = t.mc_pdgId.size()
    llpindex = []
    for i in xrange(nmc):
        #if t.mc_status[i] == 1 and t.mc_pdgId[t.mc_parent_index[i]] == 1000022:
        #print t.mc_prod_vx_x[0],t.mc_end_vx_x[i]
        if t.mc_status[i] == 2 and t.mc_pdgId[i] == 1000022 \
                and getdr(t,i) > 1e-10: # Note patch for mc_parent_index|| Algo pasa
            llpindex.append(i)#t.mc_parent_index[i])
            if len(llpindex) >= 2:
                return llpindex
    print "WARNING::ONLY FOUND %i LLP! (Event:%i)" % (len(llpindex),t.GetEntry())
    #for i in xrange(nmc):
    #	print i,t.mc_status[i],t.mc_pdgId[i],t.mc_prod_vx_x[i],t.mc_prod_vx_y[i],t.mc_prod_vx_z[i],\
            #			t.mc_end_vx_x[i],t.mc_end_vx_y[i],t.mc_end_vx_z[i]

def getmctruthinfo(t,llpindices):
    """
    """
    from math import sqrt
    sv = []
    for i in llpindices:
        sv.append({})
        # Secondary vertex (displaced) with respect the primary vertex (it means with respect
        # the production vertex 
        sv[-1]['Dtdv'] = sqrt((t.dv_X[i]-t.vx_LSP[i])**2.0+(t.dv_Y[i]-t.vy_LSP[i])**2.0)
        sv[-1]['Dzdv'] = t.dv_Z[i]-t.vz_LSP[i]
        sv[-1]['Drdv'] = sqrt(sv[-1]['Dtdv']**2.+sv[-1]['Dzdv']**2.)
        # Secondary vertex absolut info
        sv[-1]['tdv'] = sqrt(t.dv_X[i]**2.0+t.dv_Y[i]**2.0)
        sv[-1]['zdv'] = t.dv_Z[i]
        sv[-1]['rdv'] = sqrt(sv[-1]['tdv']**2.+sv[-1]['zdv']**2.)
    return sv

def filleff(t,trgdecdict,effsvinst,ignorematching=False):
    """..function:: filleff(t,trgdecdic,effsvinst[,ignoremathcing=True]) 
    The function fills the efficiencies with respect the variables 
    obtained with the 'getmctruthinfo' function. The datamember 
    '%TRNAME_isJetRoiMatched' takes into account if any RoI was matched
    with any MC-Truth particle coming from the DV. The datamember is a
    vector of ints, where each index corresponds to one DV (MC-Truth).
    Therefore, efficiencies are calculated as follows:
      * Check if any MC-particle coming from the DV has matched with
      the trigger RoI (isJetRoiMatched[i] outcome for the i-DV)  or not.
      The efficiency is evaluated as an AND (OR) if 'ignorematching'
      argumetn is set to False (True) of the matching checked and the trigger
      decision

    :param t: tree where the datamembers are stored
    :type  t: ROOT.TTree
    :param trgdecdic: dictionary with the trigger names and trigger 
                      decision per event
    :type  trgdecdic: dict(str: bool}
    :param effsvinst: efficiency class instances
    :type  effsvinst: class effsv
    :param ignorematching: argument to control if the matching betweem RoI's 
                           trigger objects and the MC-Truth info hould be
                           performed
    :type  ignorematching: bool                           
    """
    llpindices = xrange(len(t.dv_X))
    # Get the list of MC info related with the DV
    sv = getmctruthinfo(t,llpindices)
    # Getting the OR of all  the triggers
    trigdecOR = False
    for (tragname,trgdec) in trgdecdict.iteritems():
        trigdecOR = (trigdecOR or trgdec)
    # And adding it to the trgdecdict
    trgdecdict["OR"] = trigdecOR
    # Filling the efficiencies
    matchvar = "%s_isJetRoiMatched"
    presentvar = "%s_isJetRoiPresent"
    # obtaining the trigger decision in the event.
    for trgname,trgdec in trgdecdict.iteritems():
        i=0
        # Obtaining the MC-info related with the i-DV
        for svinfodict in sv:
            try:
                ispresent = bool(getattr(t,presentvar%trgname)[0])
            except AttributeError:
                ## TO BE DEPRECATED: just for backwards compability 
                ## with old RPVMCInfoTree 
                ispresent=True
                pass
            if ispresent:
                try:
                    # Now checking if the i-DV was matched with any TE
                    # in order to consider not to bias the variable of the
                    # DV MCTruth. The problem with using non-matching objects
                    # relies in the fact you're not sure what MC object is the
                    # responsible of the trigger decision, so you are biasing your 
                    # efficiency
                    ismatched = bool(getattr(t,matchvar%trgname)[i])
                    ismatched = (ismatched or ignorematching)
                    if not ismatched:
                        continue
                except AttributeError:
                    # Just controlling the OR-case
                    ismatched =1
            else:
                # Is not present is going to be considered as a fail decision
                ismatched=False
            # Filling all the variables
            for varname,val in svinfodict.iteritems():
                effsvinst.fill(trgname,varname,(trgdec and ismatched),val)
            i+=1

    return

def geteffinstance(rootfile):
    """..function:: geteffinstance(rootfile) -> effsv
    instantiate a effsv instance from a ROOT file.
    This implies that the root file should contain:
     * ROOT.TEfficiency objects with well defined names:
        * effVARNAME_TRIGGERNAME
     
    :param rootfile: the file where to find the TEfficiency objects
    :type  rootfile: str
    """
    import ROOT
    f = ROOT.TFile.Open(rootfile)
    # Get trigger names from the file in order 
    # to instanciate the eff-class
    trgnames = []
    esv = effsv()
    for tkey in f.GetListOfKeys():
        effname = tkey.GetName()
        trname = gettriggernamefrom(effname)
        varname = getvarnamefrom(effname)
        effobject = f.Get(effname)
        effobject.SetDirectory(0)
        esv.seteffobj(trname,varname,effobject)
    f.Close()
    return esv


if __name__ == '__main__':
    import sys
    import glob
    import os
    from optparse import OptionParser,OptionGroup

    defaultdir = 'user.nimrodta.SignalMC.174280.RPV_sq700_LSP500_ejets.D3PD.Final.07July2014.v1.140710111911'
    parser = OptionParser()
    parser.set_defaults(datasetdir=os.path.join('..',defaultdir),outputfile='output.root',\
            varlist='Dtdv',extracttrlist=False,activatematching=False)
    parser.add_option( '-d', '--datasetdir', action='store', type='string', dest='datasetdir',\
            help="Dataset directory")
    parser.add_option( '-o', '--outputfile', action='store', type='string', dest='outputfile',\
            help="Dataset directory")
    parser.add_option( '-p', '--plotlist', action='store', type='string', metavar='TRG1,TRG2[,...]',\
            dest = 'plotlist',help='List of trigger chain to be plotted in the same canvas')
    parser.add_option( '-v', '--varlist', action='store', type='string', metavar='VAR1,VAR2[,...]',\
            dest = 'varlist',help='List of variables to be used by the "-p" option.')
    parser.add_option( '-l', '--triggerlist', action='store_true', \
            dest = 'extracttrlist',help='Just show the available triggers in the file and exit')
    parser.add_option( '-m', '--matching', action='store_true', \
            dest = 'activatematching',help='The matching between a trigger object and the '\
              'MC-displaced vertex tracks are checked')


    (opt, args)=parser.parse_args()

    # Working Mode 2: plotting trigger efficiencies
    if len(args) == 1:
        effwrtsv = geteffinstance(args[0])
        if opt.extracttrlist:
            print "Available trigger efficiencies in '%s'" % args[0]
            for trigname in effwrtsv.gettrgnames():
                print ":::%s" % trigname
            sys.exit(0)
        print "Extracting efficiencies from the '%s' file..." % args[0]
        print "Plotting efficiencies..."
        if opt.plotlist:
            triglist = opt.plotlist.split(',')
            for varname in opt.varlist.split(','):
                effwrtsv.__plotsamecanvas__(triglist,varname)
        else:
            effwrtsv.plot()
        # Already done
        sys.exit(0)

    # Working Mode 1: extracting trigger efficiencies
    print "Creating efficiencies from: "
    ignorematching=not opt.activatematching
    # Called to build the histograms from the n-tuples
    rfiles = glob.glob(opt.datasetdir+'/*.root')
    message =''
    for _fi in rfiles: 
        message += os.path.basename(_fi)
    t = gettreechain(rfiles)
    trnames = gettriggersnames(t)
    trarrays = setuptree(t,trnames)
    eff = dict(map(lambda x: (x,0),trarrays.keys()))
    effwrtsv = effsv(trnames)
    # loop over the entries
    nentries = t.GetEntries()
    print "Processing %i events" % nentries
    message = "Evaluating MC-Truth Trigger efficiencies PER "
    if ignorematching:
        message+="EVENT"
    else:
        message+="DV object"
    print message
    for i in xrange(nentries):
        _d = t.GetEntry(i)
        trgdecisions = {}
        for trname,valarr in trarrays.iteritems():
            eff[trname] += valarr[0]
            trgdecisions[trname] = valarr[0]
        # Do it once per event, not re-looping for each trigger
        filleff(t,trgdecisions,effwrtsv,ignorematching)
    
    effwrtsv.showresults()
    effwrtsv.saverootfile(opt.outputfile)

